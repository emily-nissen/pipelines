---
title: "Bulk RNA-seq Pipeline"
author: "Emily Nissen"
date: "2024-02-07"
output: 
  github_document:
    html_preview: TRUE
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Pre-processing

## FastQC

Run FastQC to check quality of data.

Run on fastq file for each sample (if paired-end data, run on two fastq files for each sample)

<https://www.bioinformatics.babraham.ac.uk/projects/fastqc/>

```{bash, eval = F}
fastqc -o path_to_fastqc_output_folder/fastqc/ -f fastq -t 8 path_to_data_folder/sample1_R1.fastq.gz
fastqc -o path_to_fastqc_output_folder/fastqc/ -f fastq -t 8 path_to_data_folder/sample1_R2.fastq.gz
```

## MultiQC

FastQC outputs individual document for each fastq file. MultiQC will aggregate all files. Input is the folder where all FastQC reports are.

<https://multiqc.info/>

```{bash, eval = F}
multiqc --interactive path-to-fastqc-output-folder/
```

## Trimming

Only trim if needed. Usually adaptor content shows up in FastQC reports.

I typically use trimmomatic: <http://www.usadellab.org/cms/?page=trimmomatic>

Or Trim Galore!: <https://www.bioinformatics.babraham.ac.uk/projects/trim_galore/>

Trimming for Illumina universal adapters

```{bash, eval = F}
java -jar Trimmomatic-0.39/trimmomatic-0.39.jar PE -threads 8 \
path_to_data_folder/sample1_R1.fastq.gz \
path_to_data_folder/sample1_R2.fastq.gz \
path_to_data_folder/sample1_R1_paired.fastq.gz \
path_to_data_folder/sample1_R1_unpaired.fastq.gz \
path_to_data_folder/sample1_R2_paired.fastq.gz \
path_to_data_folder/sample1_R2_unpaired.fastq.gz \
ILLUMINACLIP://Trimmomatic-0.39/adapters/TruSeq3-PE-2:2:30:10 Leading:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:31
```

```{bash, eval = F}
TrimGalore-0.6.6/trim_galore --paired \
-a AGATCGGAAGAGC -a2 AAATCAAAAAAAC \
path_to_data_folder/sample1_R1.fastq.gz \
path_to_data_folder/sample1_R2.fastq.gz \
```


## Aligning

RSEM aligns to the transcriptome. Use rsem-prepare-reference to setup and index transcriptome for the organism and aligner you plan on using (this only needs to be done once). Then you can run rsem-calculate-expression to calculate expression values.

<https://github.com/deweylab/RSEM>

<https://deweylab.github.io/RSEM/rsem-calculate-expression.html>

This code will output two results files for each sample "sampleN.genes.results" and "sampleN.isoforms.results". The "sampleN.genes.results" are the expression values aggregated at the gene level. The "expected_count" column is what is needed for input in to a differential expression analysis.

rsem-calculate-expression [options] --paired-end upstream_read_file(s) downstream_read_file(s) reference_name sample_name 

```{bash, eval = F}
mkdir path_to_rsem_results/rsemResults/rsemResult_sample1

rsem-calculate-expression \
# number of threads
-p 8 \
# aligner
--bowtie2 \
--paired-end \
# generate BAM files
--output-genome-bam \
# strandedness will depend on how the libraries were prepared, default is is none
--strandedness reverse \
# upstream read file
path_to_data_folder/sample1_R1.fastq.gz \
# downstream read file
path_to_data_folder/sample1_R2.fastq.gz \
# reference_name
path_to_reference/ucsc-hg38-rsem/hg38-rsem \
#sample_name, all output files are prefixed by this name
path_to_rsem_results/rsemResults/rsemResult_sample1/sample1
```

```{bash, eval = F}
rsem-generate-data matrix \
# list all gene.results files
path_to_rsem_results/rsemResults/rsemResults_sample1/sample1.genes.results \
path_to_rsem_results/rsemResults/rsemResults_sample2/sample2.genes.results \
path_to_rsem_results/rsemResults/rsemResults_sampleN/sampleN.genes.results > genes.count.matrix
```

## MultiQC

Run multiqc again to add on mapping statistics

```{bash, eval = F}
multiqc --interactive path_to_folder_that_has_fastqcfolder_and_rsemfolder/
```

# Differential Expression Analysis

<https://bioconductor.org/packages/release/bioc/html/edgeR.html>

## Setup

```{r, echo = T, message = F}
#load any packages here
library(edgeR)
library(ggplot2)
library(dplyr)
library(org.Hs.eg.db)
library(gage)
library(pathview)
library(aliases2entrez)
library(data.table)
library(ggrepel)
library(Glimma)
library(ggpubr)
library(Rtsne)
library(UpSetR)
library(grid)
library(tidyr)
library(clusterProfiler)
library(pheatmap)
library(ggridges)
library(enrichplot)
library(ggvenn)
library(ReactomePA)

# helpful functions
source("utils_RNASeq.R")
```

## Load Data and Format as edgeR Object

```{r}
counts = read.table("genes.count.matrix", header = T, sep = "\t", row.names = 1, check.names = F)

pheno = read.csv("SampleSheet.csv")

all(colnames(counts) == pheno$Sample.Name)
# group should be whatever the experimental groups of interest are
# here I am using Cell Type (mMDSC vs Monocyte)
group = pheno$Cell.Type

# create DGEList object
y = DGEList(counts, group = factor(group))

# filter lowly expressed genes
# n is the sample size of the smallest experiment group
n = 4
# only keep genes that have more than 1 CPM in more than n samples
keep = rowSums(cpm(y)>1) >= n
sum(keep)
y = y[keep,]
dim(y)
# calculate scaling factors to convert raw library sizes into effective library sizes
y = calcNormFactors(y)
```

## Data Exploration

```{r}
pca = prcomp(t(as.matrix(y$counts)), scale = T)
summary(pca)

var_explained = pca$sdev^2/sum(pca$sdev^2)

df=as.data.frame(cbind(pca$x[,1], pca$x[,2], pca$x[,3], pca$x[,4]))
colnames(df)=c('PC1','PC2','PC3','PC4')
# add variables that might explain variation
df$Sample = colnames(counts)
df$CellType = pheno$Cell.Type
df$Gender = pheno$Gender
df$ID = pheno$Sampling.ID

df %>%
  ggplot(aes(x=PC1,y=PC2))+ 
  geom_point(aes(color = CellType, shape = Gender), size=5) +
  geom_text_repel(aes(label=ID)) +
  labs(x=paste0("PC1: ",round(var_explained[1]*100,1),"%"),
       y=paste0("PC2: ",round(var_explained[2]*100,1),"%"))

df %>%
  ggplot(aes(x=PC1,y=PC4))+ 
  geom_point(aes(color = CellType, shape = Gender), size=5) +
  geom_text_repel(aes(label=ID)) +
  labs(x=paste0("PC1: ",round(var_explained[1]*100,1),"%"),
       y=paste0("PC4: ",round(var_explained[4]*100,1),"%"))
```

## Testing for Differential Expression

### Paired Design

This is testing under a paired sample design

```{r}
ID = factor(pheno$Sampling.ID)
Cell.Type = factor(pheno$Cell.Type)
Cell.Type = relevel(Cell.Type, ref = "mono Total or Med")
# design matrix 
design = model.matrix(~ID + Cell.Type)
rownames(design) = colnames(y)
design

# estimate the negative binomial dispersion
y1 = estimateDisp(y, design, robust = T)
# coefficient of variation of biological variation
sqrt(y1$common.dispersion)
# view the dispersion estimates
plotBCV(y1)

# fit genewise GLMs
# tests are conducted for the last coefficient in the linear model (in this case the mMDSC vs Monocyte effect)
fit = glmQLFit(y1, design)
qlf = glmQLFTest(fit)

# show top 10 DEGs
topTags(qlf)

summary(decideTests(qlf, adjust.method = "BH", p.value = 0.05))
summary(decideTests(qlf, adjust.method = "BH", p.value = 0.05, lfc = 1))
```

### Unpaired Design

This would be the setup if the data were not paired

```{r}
Cell.Type = factor(pheno$Cell.Type)
# design matrix
design.notpaired = model.matrix(~0+Cell.Type)
rownames(design.notpaired) = colnames(y)
design.notpaired

# fit genewise GLMs
fit.notpaired = glmQLFit(y1, design.notpaired)
# need to create a contrast to make the comparison of interest
qlf.notpaired = glmQLFTest(fit.notpaired, contrast=c(1,-1))

# show top 10 DEGs
topTags(qlf.notpaired)
```

## Plot Results

Using the paired design.

```{r, fig.width = 16, fig.height=10}
range.x.y = c(0,1)
range.x.y[1] = max(abs(qlf$table$logFC))
range.x.y[2] = min(qlf$table$PValue)

# these are functions in the "utils_RNASeq.R" that are hopefully helpful for plotting 
# volcano plot
plot.volcano(qlf, "mMDSC vs Mono", range.x.y, "mMDSC vs Mono")
# p-value histogram
plot.pval.hist(qlf, 0.5, 1500)

# plot CPM boxplots of top N genes
N=15
o = order(qlf$table$PValue)

# by default the normalized library sizes are used in cpm
(topN = cpm(y1)[o[1:N],])

topN = as.data.frame(t(topN))
topN$Cell.Type = pheno$Cell.Typ
topN.long = gather(topN, gene, cpm, 1:N, factor_key = T)
topN.long %>%
  ggplot(aes(x = Cell.Type, y = cpm, fill = Cell.Type)) +
  geom_boxplot() +
  facet_wrap(vars(gene), scales = "free", ncol = 5)
```

# Gene Set Enrichment

## Reactome Pathways

```{r, fig.width = 16, fig.height=10}
gene.list = qlf$table$logFC
names = read.csv("rsem_gene_symbols_entrez.csv")
names = subset(names, SYMBOL%in%rownames(qlf$table))
# Names of gene list must be Entrez IDs
names(gene.list) = names$ENTREZID
# Sort in decreasing order
gene.list = sort(gene.list, decreasing = T)

gseReactome = gsePathway(gene = gene.list, pvalueCutoff = 0.05)

dotplot(gseReactome)

# plot Normalized Enrichment Score
plot.bar.NES(gseReactome@result, gseReactome@result$qvalues, "q-value")
```
